To-Do for NEXT update
- lobby adv
- lobby average rank
- pub/priv


Advantage Formula:
((AverageMarineRank - ZombieRank) / 7 + (AverageMarineRank + ZombieRank) - 31) / 31


Things to do
 - Add ARES tank mods
 - Add diverts
 - Add save files to user/documents feature
   - Maybe as onizanalyzer
 - Viro
 - How many upgraded structures are built (check UnitTypeChanges)


Much more down the line
- bank reclaimer
- discord bot
- player improvement suggestions
    - average unspent gas throughout the game?
- marginal analysis
    - make game ID (re-hash the compounded player signatures), and if it exists in the excel file, then don't analyze
    - would also have to add to previous file
- leaver lobby analysis



Needs Fixes
- creep tower count is weird?

Data to be Added
- lobby average rank
- pub/private check
- lobby advantage



226 - 5.6 ~ 6.5 sec
16 - 2.1 seconds
142 - 4.1 seconds
120~ takes roughly 2 seconds, so maybe 60 per second? Initial time of 2 seconds?


Bank data analysis
- Goal: outline the most recent bank data
- How to: match username and handle to find latest data
- Requisites:
    1. If bank reset has been detected, then keep last data and add on any future data to it
        possibly detect final data and add in any 'resets' that have happened? (1) - reset - (2) -> (1) + (2)
        What if bank has been recovered? If significant gap is detected, then add the data right before this to it?
    2. handle should be the main go-to for player identification (how to obtain this though?)
    3. data structure should be totaldict: {handle - playerdict}, playerdict: {key - values} (kv in playerdict should be the data from bank)
- Procedure:
    1. mine data from replay
    2. match mined data with previous data
        1) if previous data exists, then add onto previous data
        2) if new data, then create data


bankinfoprocess outputs player bank data as dict
the functions process gathers the dict, and if there is a clash, overwrites the dict depending on dict date




    def create_dataframes(self):
        self.dataframe_human = pd.DataFrame.from_records(self.replays_data_human_list, columns=total_df_human_column_list)
        self.dataframe_zombie = pd.DataFrame.from_records(self.replays_data_zombie_list, columns=total_df_zombie_column_list)

    def create_excel_file(self, path):
        h_writer = pd.ExcelWriter(f'{path}/#Humandata.xlsx', engine='xlsxwriter')
        z_writer = pd.ExcelWriter(f'{path}/#Zombiedata.xlsx', engine='xlsxwriter')

        self.adjust_excel_data(h_writer, self.dataframe_human)
        self.adjust_excel_data(z_writer, self.dataframe_zombie)

    def adjust_excel_data(self, writer, df):
        df.to_excel(writer, sheet_name='Human Data', startrow=1, header=False, index=False)
        worksheet = writer.sheets['Human Data']

        (max_row, max_col) = df.shape
        column_settings = [{'header': column} for column in df.columns]

        worksheet.add_table(0, 0, max_row, max_col - 1, {'columns': column_settings})

        for i, width in enumerate(get_col_widths(df)):
            worksheet.set_column(i-1, i, width+2)

        writer.close()